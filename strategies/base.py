"""
Strategy base class for Paradex Trader.

All trading strategies must inherit from BaseStrategy and implement:
- should_enter(): Determine if we should enter a trade
- calculate_exit(): Calculate exit levels (TP/SL)
- should_exit_early(): Optional early exit logic
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple
import logging

logger = logging.getLogger("paradex_trader.strategy")


class Direction(Enum):
    """Trade direction."""
    LONG = "LONG"
    SHORT = "SHORT"
    NEUTRAL = "NEUTRAL"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Attributes:
        direction: Trade direction (LONG, SHORT, or NEUTRAL).
        strength: Signal strength from 0.0 to 1.0.
        strategy: Name of the strategy that generated this signal.
        reason: Human-readable reason for the signal.
        features: Dictionary of features used to generate the signal.
        timestamp: When the signal was generated.
        metadata: Optional additional data.
    """
    direction: Direction
    strength: float
    strategy: str
    reason: str
    features: Dict[str, float]
    timestamp: float
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal parameters."""
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError(f"Signal strength must be between 0 and 1, got {self.strength}")

    @property
    def is_valid(self) -> bool:
        """Check if signal is actionable."""
        return self.direction != Direction.NEUTRAL and self.strength > 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "direction": self.direction.value,
            "strength": self.strength,
            "strategy": self.strategy,
            "reason": self.reason,
            "features": self.features,
            "timestamp": self.timestamp,
            "metadata": self.metadata,
        }


@dataclass
class ExitLevels:
    """
    Exit price levels for a trade.

    Attributes:
        take_profit: Take profit price.
        stop_loss: Stop loss price.
        trailing_trigger: Price at which to activate trailing stop.
        trailing_distance: Distance for trailing stop (in price or %).
        time_stop_seconds: Maximum hold time before exit.
    """
    take_profit: float
    stop_loss: float
    trailing_trigger: Optional[float] = None
    trailing_distance: Optional[float] = None
    time_stop_seconds: Optional[float] = None

    def validate(self, entry_price: float, direction: Direction) -> bool:
        """
        Validate exit levels make sense for the trade direction.

        Args:
            entry_price: Entry price of the trade.
            direction: Trade direction.

        Returns:
            True if levels are valid.
        """
        if direction == Direction.LONG:
            return self.take_profit > entry_price > self.stop_loss
        elif direction == Direction.SHORT:
            return self.take_profit < entry_price < self.stop_loss
        return False

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "take_profit": self.take_profit,
            "stop_loss": self.stop_loss,
            "trailing_trigger": self.trailing_trigger,
            "trailing_distance": self.trailing_distance,
            "time_stop_seconds": self.time_stop_seconds,
        }


@dataclass
class TradeContext:
    """
    Context information for trade decisions.

    Contains all relevant data for strategy evaluation.
    """
    # Current market data
    bid: float
    ask: float
    mid_price: float
    spread_pct: float

    # Orderbook data
    imbalance: float = 0.0
    bid_depth: float = 0.0
    ask_depth: float = 0.0

    # Account state
    balance: float = 0.0
    has_position: bool = False
    position_side: Optional[Direction] = None
    position_size: float = 0.0
    position_pnl: float = 0.0

    # Risk state
    daily_pnl: float = 0.0
    consecutive_losses: int = 0
    is_in_cooldown: bool = False

    # Timestamp
    timestamp: float = 0.0


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Strategies must implement:
    - should_enter(): Determine if we should enter a trade
    - calculate_exit(): Calculate exit levels for a trade

    Optionally override:
    - should_exit_early(): Custom early exit logic
    - get_position_size_multiplier(): Adjust position size based on signal
    - on_trade_opened(): Called when a trade is opened
    - on_trade_closed(): Called when a trade is closed
    """

    def __init__(self, name: str, config: Dict[str, Any]):
        """
        Initialize strategy.

        Args:
            name: Strategy name.
            config: Strategy configuration dictionary.
        """
        self.name = name
        self.config = config
        self.is_enabled = True

        # Performance tracking
        self.total_trades = 0
        self.winning_trades = 0
        self.total_pnl = 0.0
        self.recent_signals: List[Signal] = []
        self._max_recent_signals = 100

        # State
        self._last_signal_time: float = 0
        self._min_signal_interval: float = config.get("min_signal_interval", 5.0)

        logger.info(f"Strategy initialized: {name}")

    @abstractmethod
    async def should_enter(
        self,
        features: Dict[str, float],
        context: TradeContext,
    ) -> Optional[Signal]:
        """
        Determine if we should enter a trade.

        Args:
            features: Calculated feature dictionary from FeatureEngine.
            context: Current trade context with market and account data.

        Returns:
            Signal object if entry conditions are met, None otherwise.
        """
        pass

    @abstractmethod
    def calculate_exit(
        self,
        entry_price: float,
        direction: Direction,
        features: Dict[str, float],
    ) -> ExitLevels:
        """
        Calculate exit levels for a trade.

        Args:
            entry_price: Entry price of the trade.
            direction: Trade direction (LONG or SHORT).
            features: Features at time of entry.

        Returns:
            ExitLevels object with TP/SL levels.
        """
        pass

    def should_exit_early(
        self,
        current_price: float,
        entry_price: float,
        direction: Direction,
        hold_time: float,
        features: Dict[str, float],
        exit_levels: ExitLevels,
    ) -> Tuple[bool, str]:
        """
        Determine if we should exit a trade early.

        Override this method to implement custom early exit logic.

        Args:
            current_price: Current market price.
            entry_price: Trade entry price.
            direction: Trade direction.
            hold_time: Time held in seconds.
            features: Current features.
            exit_levels: Original exit levels.

        Returns:
            Tuple of (should_exit, reason).
        """
        # Default: check time stop
        if exit_levels.time_stop_seconds and hold_time >= exit_levels.time_stop_seconds:
            return True, "time_stop"

        return False, ""

    def get_position_size_multiplier(
        self,
        signal: Signal,
        features: Dict[str, float],
    ) -> float:
        """
        Get position size multiplier based on signal strength.

        Override to implement dynamic position sizing.

        Args:
            signal: The generated signal.
            features: Current features.

        Returns:
            Multiplier between 0.5 and 2.0.
        """
        # Default: scale linearly with signal strength
        # strength 0.4 -> 0.5x, strength 1.0 -> 1.5x
        multiplier = 0.5 + signal.strength
        return max(0.5, min(2.0, multiplier))

    def check_entry_filters(
        self,
        features: Dict[str, float],
        context: TradeContext,
    ) -> Tuple[bool, str]:
        """
        Check common entry filters before strategy-specific logic.

        Args:
            features: Feature dictionary.
            context: Trade context.

        Returns:
            Tuple of (passed, rejection_reason).
        """
        # Spread filter
        max_spread = self.config.get("max_spread_pct", 0.015)
        if context.spread_pct > max_spread:
            return False, f"spread_too_high ({context.spread_pct:.4f} > {max_spread})"

        # Cooldown filter
        if context.is_in_cooldown:
            return False, "in_cooldown"

        # Already has position
        if context.has_position:
            return False, "has_position"

        # Signal interval (prevent spam)
        import time
        now = time.time()
        if now - self._last_signal_time < self._min_signal_interval:
            return False, "signal_too_soon"

        return True, ""

    def update_last_signal_time(self) -> None:
        """Update the last signal timestamp."""
        import time
        self._last_signal_time = time.time()

    def record_signal(self, signal: Signal) -> None:
        """
        Record a signal for analysis.

        Args:
            signal: Signal to record.
        """
        self.recent_signals.append(signal)
        if len(self.recent_signals) > self._max_recent_signals:
            self.recent_signals.pop(0)

    def on_trade_opened(
        self,
        trade_id: str,
        direction: Direction,
        entry_price: float,
        size: float,
        signal: Signal,
    ) -> None:
        """
        Called when a trade is opened using this strategy.

        Override to implement custom logic.

        Args:
            trade_id: Unique trade ID.
            direction: Trade direction.
            entry_price: Entry price.
            size: Position size.
            signal: Signal that triggered the trade.
        """
        self.total_trades += 1
        logger.info(
            f"[{self.name}] Trade opened: {direction.value} @ {entry_price:.2f}, "
            f"size={size}, signal_strength={signal.strength:.2f}"
        )

    def on_trade_closed(
        self,
        trade_id: str,
        direction: Direction,
        entry_price: float,
        exit_price: float,
        pnl: float,
        pnl_pct: float,
        reason: str,
    ) -> None:
        """
        Called when a trade is closed.

        Override to implement custom logic.

        Args:
            trade_id: Unique trade ID.
            direction: Trade direction.
            entry_price: Entry price.
            exit_price: Exit price.
            pnl: Profit/loss amount.
            pnl_pct: Profit/loss percentage.
            reason: Exit reason.
        """
        if pnl > 0:
            self.winning_trades += 1

        self.total_pnl += pnl

        logger.info(
            f"[{self.name}] Trade closed: {direction.value} @ {exit_price:.2f}, "
            f"PnL={pnl:+.4f} ({pnl_pct:+.2%}), reason={reason}"
        )

    def get_stats(self) -> Dict[str, Any]:
        """
        Get strategy statistics.

        Returns:
            Dictionary with strategy stats.
        """
        win_rate = self.winning_trades / self.total_trades if self.total_trades > 0 else 0

        return {
            "name": self.name,
            "is_enabled": self.is_enabled,
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "win_rate": win_rate,
            "total_pnl": self.total_pnl,
            "recent_signals_count": len(self.recent_signals),
        }

    def enable(self) -> None:
        """Enable the strategy."""
        self.is_enabled = True
        logger.info(f"Strategy enabled: {self.name}")

    def disable(self) -> None:
        """Disable the strategy."""
        self.is_enabled = False
        logger.info(f"Strategy disabled: {self.name}")

    def reset_stats(self) -> None:
        """Reset strategy statistics."""
        self.total_trades = 0
        self.winning_trades = 0
        self.total_pnl = 0.0
        self.recent_signals.clear()
        logger.info(f"Strategy stats reset: {self.name}")

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name='{self.name}', enabled={self.is_enabled})"


class StrategyManager:
    """
    Manages multiple trading strategies.

    Handles strategy selection, signal aggregation, and performance tracking.
    """

    def __init__(self, strategies: List[BaseStrategy]):
        """
        Initialize strategy manager.

        Args:
            strategies: List of strategy instances.
        """
        self.strategies: Dict[str, BaseStrategy] = {s.name: s for s in strategies}
        self._active_strategy: Optional[str] = None

        logger.info(f"StrategyManager initialized with {len(strategies)} strategies")

    def get_strategy(self, name: str) -> Optional[BaseStrategy]:
        """Get a strategy by name."""
        return self.strategies.get(name)

    def get_enabled_strategies(self) -> List[BaseStrategy]:
        """Get all enabled strategies."""
        return [s for s in self.strategies.values() if s.is_enabled]

    def set_active_strategy(self, name: str) -> bool:
        """
        Set the active strategy (for single-strategy mode).

        Args:
            name: Strategy name.

        Returns:
            True if set successfully.
        """
        if name in self.strategies:
            self._active_strategy = name
            logger.info(f"Active strategy set to: {name}")
            return True
        return False

    def get_active_strategy(self) -> Optional[BaseStrategy]:
        """Get the currently active strategy."""
        if self._active_strategy:
            return self.strategies.get(self._active_strategy)
        return None

    async def get_signals(
        self,
        features: Dict[str, float],
        context: TradeContext,
    ) -> List[Signal]:
        """
        Get signals from all enabled strategies.

        Args:
            features: Feature dictionary.
            context: Trade context.

        Returns:
            List of signals from all strategies.
        """
        signals = []

        for strategy in self.get_enabled_strategies():
            try:
                signal = await strategy.should_enter(features, context)
                if signal and signal.is_valid:
                    signals.append(signal)
            except Exception as e:
                logger.error(f"Error getting signal from {strategy.name}: {e}")

        return signals

    def get_best_signal(self, signals: List[Signal]) -> Optional[Signal]:
        """
        Get the best signal from a list.

        Args:
            signals: List of signals.

        Returns:
            Signal with highest strength, or None.
        """
        if not signals:
            return None

        return max(signals, key=lambda s: s.strength)

    def get_all_stats(self) -> Dict[str, Dict[str, Any]]:
        """Get statistics for all strategies."""
        return {name: s.get_stats() for name, s in self.strategies.items()}

    def enable_all(self) -> None:
        """Enable all strategies."""
        for strategy in self.strategies.values():
            strategy.enable()

    def disable_all(self) -> None:
        """Disable all strategies."""
        for strategy in self.strategies.values():
            strategy.disable()
